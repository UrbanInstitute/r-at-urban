# set colors
values = palette_urbn_cyan[c(2, 3, 5, 7)],
# Make legend title more readable
name = "CHIP Enrollment %",
# Show top and bottom limits on legend
show.limits = TRUE,
# Roughly set number of bins. Won't be exact as R uses algorithms under the
# hood for pretty looking breaks.
n.breaks = 4
)
## plot tile grid
geo_grid_data %>%
ggplot(aes(x = col, y = row, fill = chip_enrollment)) +
scale_fill_steps(
# Convert legend from decimal to percentages
labels = scales::percent_format(),
# set colors
#values = palette_urbn_cyan[c(2, 3, 5, 7)],
# Make legend title more readable
name = "CHIP Enrollment %",
# Show top and bottom limits on legend
show.limits = TRUE,
# Roughly set number of bins. Won't be exact as R uses algorithms under the
# hood for pretty looking breaks.
n.breaks = 4
)
## plot tile grid
geo_grid_data %>%
ggplot(aes(x = col, y = row, fill = chip_enrollment)) +
scale_fill_steps(
# Convert legend from decimal to percentages
labels = scales::percent_format(),
# set colors
#values = palette_urbn_cyan[c(2, 3, 5, 7)],
# Make legend title more readable
name = "CHIP Enrollment %",
# Show top and bottom limits on legend
show.limits = TRUE,
# Roughly set number of bins. Won't be exact as R uses algorithms under the
# hood for pretty looking breaks.
n.breaks = 4
)+
# scale_fill_manual(values = palette_urbn_cyan[c(2, 5, 7)]) +
geom_tile(color = "white", linewidth = 1) +
geom_text(aes(label = code), color="white", size = 4) +
scale_y_reverse() +
coord_equal() +
labs(fill=NULL)+
theme(legend.position = "none")
## plot tile grid
geo_grid_data %>%
ggplot(aes(x = col, y = row, fill = chip_enrollment)) +
scale_fill_steps(
# Convert legend from decimal to percentages
labels = scales::percent_format(),
# set colors
#values = palette_urbn_cyan[c(2, 3, 5, 7)],
# Make legend title more readable
name = "CHIP Enrollment %",
# Show top and bottom limits on legend
show.limits = TRUE,
# Roughly set number of bins. Won't be exact as R uses algorithms under the
# hood for pretty looking breaks.
n.breaks = 3
)+
# scale_fill_manual(values = palette_urbn_cyan[c(2, 5, 7)]) +
geom_tile(color = "white", linewidth = 1) +
geom_text(aes(label = code), color="white", size = 4) +
scale_y_reverse() +
coord_equal() +
labs(fill=NULL)+
theme(legend.position = "none")
# create a grid with all of the US states and territories
mygrid <- data.frame(
code = c("ME", "AK", "WI", "VT", "NH", "IL", "ID", "WA", "MN", "MT", "ND", "MI", "NY", "MA", "IA", "IN", "CT", "RI", "NJ", "PA", "OH", "SD", "WY", "NV", "OR", "CA", "NE", "DE", "MD", "VA", "WV", "KY", "MO", "CO", "UT", "AZ", "KS", "AR", "DC", "SC", "NC", "TN", "NM", "LA", "AL", "GA", "MS", "OK", "HI", "PR", "MP", "FL", "TX"),
row = c(1, 1, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8),
col = c(12, 2, 7, 11, 12, 7, 3, 2, 6, 4, 5, 8, 10, 11, 6, 7, 11, 12, 10, 9, 8, 5, 4, 3, 2, 2, 5, 11, 10, 9, 8, 7, 6, 4, 3, 3, 5, 6, 10, 9, 8, 7, 4, 6, 8, 9, 7, 5, 2, 12, 1, 10, 5),
stringsAsFactors = FALSE
)
## Combine data into geo_grid for tiling:
geo_grid_data <- mygrid %>%
left_join(chip_with_geographies, by=c("code" = "state_abbv"))
## plot tile grid
geo_grid_data %>%
ggplot(aes(x = col, y = row, fill = chip_enrollment)) +
scale_fill_steps(
# Convert legend from decimal to percentages
labels = scales::percent_format(),
# set colors
#values = palette_urbn_cyan[c(2, 3, 5, 7)],
# Make legend title more readable
name = "CHIP Enrollment %",
# Show top and bottom limits on legend
show.limits = TRUE,
# Roughly set number of bins. Won't be exact as R uses algorithms under the
# hood for pretty looking breaks.
n.breaks = 3
)+
# scale_fill_manual(values = palette_urbn_cyan[c(2, 5, 7)]) +
geom_tile(color = "white", linewidth = 1) +
geom_text(aes(label = code), color="white", size = 4) +
scale_y_reverse() +
coord_equal() +
labs(fill=NULL)+
theme(legend.position = "none")
# create a grid with all of the US states and territories
mygrid <- data.frame(
code = c("ME", "AK", "WI", "VT", "NH", "IL", "ID", "WA", "MN", "MT", "ND", "MI", "NY", "MA", "IA", "IN", "CT", "RI", "NJ", "PA", "OH", "SD", "WY", "NV", "OR", "CA", "NE", "DE", "MD", "VA", "WV", "KY", "MO", "CO", "UT", "AZ", "KS", "AR", "DC", "SC", "NC", "TN", "NM", "LA", "AL", "GA", "MS", "OK", "HI", "FL", "TX"),
row = c(1, 1, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 8, 8, 8),
col = c(12, 2, 7, 11, 12, 7, 3, 2, 6, 4, 5, 8, 10, 11, 6, 7, 11, 12, 10, 9, 8, 5, 4, 3, 2, 2, 5, 11, 10, 9, 8, 7, 6, 4, 3, 3, 5, 6, 10, 9, 8, 7, 4, 6, 8, 9, 7, 5, 2, 10, 5),
stringsAsFactors = FALSE
)
## Combine data into geo_grid for tiling:
geo_grid_data <- mygrid %>%
left_join(chip_with_geographies, by=c("code" = "state_abbv"))
## plot tile grid
geo_grid_data %>%
ggplot(aes(x = col, y = row, fill = chip_enrollment)) +
scale_fill_steps(
# Convert legend from decimal to percentages
labels = scales::percent_format(),
# set colors
#values = palette_urbn_cyan[c(2, 3, 5, 7)],
# Make legend title more readable
name = "CHIP Enrollment %",
# Show top and bottom limits on legend
show.limits = TRUE,
# Roughly set number of bins. Won't be exact as R uses algorithms under the
# hood for pretty looking breaks.
n.breaks = 3
)+
# scale_fill_manual(values = palette_urbn_cyan[c(2, 5, 7)]) +
geom_tile(color = "white", linewidth = 1) +
geom_text(aes(label = code), color="white", size = 4) +
scale_y_reverse() +
coord_equal() +
labs(fill=NULL)+
theme(legend.position = "none")
View(chip_with_geographies)
## plot tile grid
geo_grid_data %>%
ggplot(aes(x = col, y = row, fill = chip_enrollment)) +
scale_fill_steps(
# Convert legend from decimal to percentages
labels = scales::percent_format(),
# set colors
#values = palette_urbn_cyan[c(2, 3, 5, 7)],
# Make legend title more readable
name = "CHIP Enrollment %",
# Show top and bottom limits on legend
show.limits = TRUE,
# Roughly set number of bins. Won't be exact as R uses algorithms under the
# hood for pretty looking breaks.
n.breaks = 4
)+
# scale_fill_manual(values = palette_urbn_cyan[c(2, 5, 7)]) +
geom_tile(color = "white", linewidth = 1) +
geom_text(aes(label = code), color="white", size = 4) +
scale_y_reverse() +
coord_equal() +
labs(fill=NULL)+
theme(legend.position = "none")
chip_with_geographies %>%
ggplot() +
geom_sf(aes(
# Color in states by the chip_pct variable
fill = chip_pct
)) +
scale_fill_steps(
# Convert legend from decimal to percentages
labels = scales::percent_format(),
# Make legend title more readable
name = "CHIP Enrollment %",
# Show top and bottom limits on legend
show.limits = TRUE,
# Roughly set number of bins. Won't be exact as R uses algorithms under the
# hood for pretty looking breaks.
n.breaks = 5
)
## plot tile grid
geo_grid_data %>%
ggplot(aes(x = col, y = row, fill = chip_enrollment)) +
scale_fill_steps(
# Convert legend from decimal to percentages
labels = scales::percent_format(),
# set colors
#values = palette_urbn_cyan[c(2, 3, 5, 7)],
# Make legend title more readable
name = "CHIP Enrollment %",
# Show top and bottom limits on legend
show.limits = TRUE,
# Roughly set number of bins. Won't be exact as R uses algorithms under the
# hood for pretty looking breaks.
n.breaks = 5
)+
# scale_fill_manual(values = palette_urbn_cyan[c(2, 5, 7)]) +
geom_tile(color = "white", linewidth = 1) +
geom_text(aes(label = code), color="white", size = 4) +
scale_y_reverse() +
coord_equal() +
labs(fill=NULL)+
theme(legend.position = "none")
## plot tile grid
geo_grid_data %>%
ggplot(aes(x = col, y = row, fill = chip_enrollment)) +
scale_fill_steps(
# Convert legend from decimal to percentages
labels = scales::percent_format(),
# Show top and bottom limits on legend
show.limits = TRUE,
# Roughly set number of bins. Won't be exact as R uses algorithms under the
# hood for pretty looking breaks.
n.breaks = 5
)+
# scale_fill_manual(values = palette_urbn_cyan[c(2, 5, 7)]) +
geom_tile(color = "white", linewidth = 1) +
geom_text(aes(label = code), color="white", size = 4) +
scale_y_reverse() +
coord_equal() +
labs(fill=NULL)+
theme(legend.position = "none")
# create a grid with all of the US states and territories
mygrid <- data.frame(
code = c("ME", "AK", "WI", "VT", "NH", "IL", "ID", "WA", "MN", "MT", "ND", "MI", "NY", "MA", "IA", "IN", "CT", "RI", "NJ", "PA", "OH", "SD", "WY", "NV", "OR", "CA", "NE", "DE", "MD", "VA", "WV", "KY", "MO", "CO", "UT", "AZ", "KS", "AR", "DC", "SC", "NC", "TN", "NM", "LA", "AL", "GA", "MS", "OK", "HI", "FL", "TX"),
row = c(1, 1, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 8, 8, 8),
col = c(12, 2, 7, 11, 12, 7, 3, 2, 6, 4, 5, 8, 10, 11, 6, 7, 11, 12, 10, 9, 8, 5, 4, 3, 2, 2, 5, 11, 10, 9, 8, 7, 6, 4, 3, 3, 5, 6, 10, 9, 8, 7, 4, 6, 8, 9, 7, 5, 2, 10, 5),
stringsAsFactors = FALSE
)
## Combine data into geo_grid for tiling:
geo_grid_data <- mygrid %>%
left_join(chip_with_geographies, by=c("code" = "state_abbv"))
## plot tile grid
geo_grid_data %>%
ggplot(aes(x = col, y = row, fill = chip_enrollment)) +
scale_fill_steps(
# Convert legend from decimal to percentages
labels = scales::percent_format(),
# Show top and bottom limits on legend
show.limits = TRUE,
# Roughly set number of bins. Won't be exact as R uses algorithms under the
# hood for pretty looking breaks.
n.breaks = 5
)+
# scale_fill_manual(values = palette_urbn_cyan[c(2, 5, 7)]) +
geom_tile(color = "white", linewidth = 1) +
geom_text(aes(label = code), color="white", size = 4) +
scale_y_reverse() +
coord_equal() +
labs(fill=NULL)+
theme(legend.position = "none")
# Helper function to clean up R generated intervals into nice looking interval labels
format_interval <- function(interval_text) {
text <- interval_text %>%
# Remove open and close brackets which is R generated math notation
str_remove_all("\\(") %>%
str_remove_all("\\)") %>%
str_remove_all("\\[") %>%
str_remove_all("\\]") %>%
str_replace_all(",", " — ")
# Convert decimal ranges to percent ranges
text <- text %>%
str_split(" — ") %>%
map(~ as.numeric(.x) %>%
scales::percent() %>%
paste0(collapse = " — ")) %>%
unlist() %>%
# By default character vectors are plotted in alphabetical order. We want
# factors in reverse alphabetical order to get correct colors in ggplot
fct_rev()
return(text)
}
chip_with_geographies <- chip_with_geographies %>%
# cut_interval into n groups with equal range. Set boundary so 0 is included in the bins
mutate(chip_pct_interval = cut_interval(chip_pct, n = 5)) %>%
# Generate nice looking interval labels
mutate(chip_pct_interval = format_interval(chip_pct_interval))
## plot tile grid
geo_grid_data %>%
ggplot(aes(x = col, y = row, fill = chip_enrollment)) +
scale_fill_manual(values = palette_urbn_cyan[c(2, 5, 7)]) +
geom_tile(color = "white", linewidth = 1) +
geom_text(aes(label = code), color="white", size = 4) +
scale_y_reverse() +
coord_equal() +
labs(fill=NULL)+
theme(legend.position = "none")
View(chip_with_geographies)
## plot tile grid
geo_grid_data %>%
ggplot(aes(x = col, y = row, fill = chip_pct)) +
scale_fill_manual(values = palette_urbn_cyan[c(2, 5, 7)]) +
geom_tile(color = "white", linewidth = 1) +
geom_text(aes(label = code), color="white", size = 4) +
scale_y_reverse() +
coord_equal() +
labs(fill=NULL)+
theme(legend.position = "none")
## plot tile grid
geo_grid_data %>%
ggplot(aes(x = col, y = row, fill = chip_pct)) +
scale_fill_steps(
# Convert legend from decimal to percentages
labels = scales::percent_format(),
# Show top and bottom limits on legend
show.limits = TRUE,
# Roughly set number of bins. Won't be exact as R uses algorithms under the
# hood for pretty looking breaks.
n.breaks = 4
)+
# scale_fill_manual(values = palette_urbn_cyan[c(2, 5, 7)]) +
geom_tile(color = "white", linewidth = 1) +
geom_text(aes(label = code), color="white", size = 4) +
scale_y_reverse() +
coord_equal() +
labs(fill=NULL)+
theme(legend.position = "none")
## plot tile grid
geo_grid_data %>%
ggplot(aes(x = col, y = row, fill = chip_pct)) +
scale_fill_manual(values = palette_urbn_cyan[c(2, 5, 7)]) +
geom_tile(color = "white", linewidth = 1) +
geom_text(aes(label = code), color="white", size = 4) +
scale_y_reverse() +
coord_equal() +
labs(fill=NULL)+
theme(legend.position = "none")
## plot tile grid
geo_grid_data %>%
ggplot(aes(x = col, y = row, fill = chip_pct)) +
scale_fill_discrete(values = palette_urbn_cyan[c(2, 5, 7)]) +
geom_tile(color = "white", linewidth = 1) +
geom_text(aes(label = code), color="white", size = 4) +
scale_y_reverse() +
coord_equal() +
labs(fill=NULL)+
theme(legend.position = "none")
View(chip_with_geographies)
## plot tile grid
geo_grid_data %>%
ggplot(aes(x = col, y = row, fill = chip_pct_interval)) +
scale_fill_manual(values = palette_urbn_cyan[c(2, 5, 7)]) +
geom_tile(color = "white", linewidth = 1) +
geom_text(aes(label = code), color="white", size = 4) +
scale_y_reverse() +
coord_equal() +
labs(fill=NULL)+
theme(legend.position = "none")
## plot tile grid
geo_grid_data %>%
ggplot(aes(x = col, y = row, fill = chip_pct_interval)) +
scale_fill_manual(values = palette_urbn_cyan[c(2, 5, 7)]) +
geom_tile(color = "white", linewidth = 1) +
geom_text(aes(label = code), color="white", size = 4) +
scale_y_reverse() +
coord_equal() +
labs(fill=NULL)+
theme(legend.position = "none")
id_data <- mygrid %>%
left
## Combine data into geo_grid for tiling:
geo_grid_data <- mygrid %>%
left_join(chip_with_geographies, by=c("code" = "state_abbv"))
## plot tile grid
geo_grid_data %>%
ggplot(aes(x = col, y = row, fill = chip_pct_interval)) +
scale_fill_manual(values = palette_urbn_cyan[c(2, 5, 7)]) +
geom_tile(color = "white", linewidth = 1) +
geom_text(aes(label = code), color="white", size = 4) +
scale_y_reverse() +
coord_equal() +
labs(fill=NULL)+
theme(legend.position = "none")
## plot tile grid
geo_grid_data %>%
ggplot(aes(x = col, y = row, fill = chip_pct_interval)) +
scale_fill_manual(values = palette_urbn_cyan[c(8, 7, 5, 3, 1)]) +
geom_tile(color = "white", linewidth = 1) +
geom_text(aes(label = code), color="white", size = 4) +
scale_y_reverse() +
coord_equal() +
labs(fill=NULL)+
theme(legend.position = "none")
## plot tile grid
geo_grid_data %>%
ggplot(aes(x = col, y = row, fill = chip_pct_interval)) +
scale_fill_manual(values = palette_urbn_cyan[c(8, 7, 5, 3, 1)]) +
geom_tile(color = "white", linewidth = 1) +
geom_text(aes(label = code), color="white", size = 4) +
scale_y_reverse() +
coord_equal() +
labs(fill=NULL)
## plot tile grid
geo_grid_data %>%
ggplot(aes(x = col, y = row, fill = chip_pct_interval)) +
scale_fill_manual(values = palette_urbn_cyan[c(8, 7, 5, 3, 1)],
name = "CHIP Enrollment %") +
geom_tile(color = "white", linewidth = 1) +
geom_text(aes(label = code), color="white", size = 4) +
scale_y_reverse() +
coord_equal() +
labs(fill=NULL)
library(future.apply)
# install.packages("future.apply")
library(future.apply)
plan(multisession)
out <- future_lapply(x, sqrt)
knitr::opts_chunk$set(message = FALSE)
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(warning = FALSE)
options(scipen = 999)
library(profvis)
library(dplyr)
profvis({
diamonds <- read.csv("optimization/data/diamonds.csv")
diamonds_by_cut <- diamonds %>%
group_by(cut) %>%
summarise_if(is.numeric, mean)
write.csv(diamonds_by_cut, file = "optimization/data/diamonds_by_cut.csv")
})
library(microbenchmark)
microbenchmark(
read.csv("optimization/data/diamonds.csv"),
readr::read_csv("optimization/data/diamonds.csv")
)
x <- c(1, 4, 9, 16)
out <- vector("list", length(x))
for (i in seq_along(x)) {
out[[i]] <- sqrt(x[[i]])
}
unlist(out)
x <- c(1, 4, 9, 16)
out <- lapply(x, sqrt)
unlist(out)
library(purrr)
x <- c(1, 4, 9, 16)
out <- map(x, sqrt)
unlist(out)
# install.packages("future.apply")
library(future.apply)
plan(multisession)
out <- future_lapply(x, sqrt)
unlist(out)
# install.packages("furrr")
library(furrr)
plan(multiprocess)
# install.packages("future.apply")
library(future.apply)
future::plan(multisession)
out <- future_lapply(x, sqrt)
unlist(out)
renv::status()
knitr::opts_chunk$set(message = FALSE)
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(warning = FALSE)
options(scipen = 999)
library(profvis)
library(dplyr)
profvis({
diamonds <- read.csv("optimization/data/diamonds.csv")
diamonds_by_cut <- diamonds %>%
group_by(cut) %>%
summarise_if(is.numeric, mean)
write.csv(diamonds_by_cut, file = "optimization/data/diamonds_by_cut.csv")
})
library(microbenchmark)
microbenchmark(
read.csv("optimization/data/diamonds.csv"),
readr::read_csv("optimization/data/diamonds.csv")
)
x <- c(1, 4, 9, 16)
out <- vector("list", length(x))
for (i in seq_along(x)) {
out[[i]] <- sqrt(x[[i]])
}
unlist(out)
lapply(X, FUN, ...)
x <- c(1, 4, 9, 16)
out <- lapply(x, sqrt)
unlist(out)
library(purrr)
x <- c(1, 4, 9, 16)
out <- map(x, sqrt)
unlist(out)
# install.packages("future.apply")
library(future.apply)
plan(multisession)
out <- future_lapply(x, sqrt)
unlist(out)
# install.packages("furrr")
library(furrr)
plan(multisession)
y <- future_map(x, sqrt)
unlist(y)
library(future.apply)
plan(multisession())
plan(multisession)
library(future.apply)
plan(multisession)
x <- c(1, 4, 9, 16)
microbenchmark::microbenchmark(
sequential = lapply(x, sqrt),
parallel = future_lapply(x, sqrt),
unit = "s"
)
df <- ggplot2::diamonds
df <- dplyr::select(df, -c(cut, color, clarity))
centers = 2:5
system.time(
lapply(centers,
function(x) kmeans(df, centers = x, nstart = 500)
)
)
